#include <iostream>
#include <cstdlib>
#include <vector>

using namespace std;


// Узел декартового дерева по неявному ключу. Главное отличие - мы больше не храним
// ключ в явном виде, вместо этого мы просто храним размер поддерева с корнем
// в данном узле. Доступ к элементам дерева будет осуществляться по вычисляемому
// "номеру" вершины, равному её порядковому номеру при прямом (Л-К-П) обходе.
struct Node {
    int y;   // Как и прежде, "приоритет" вершины
    int sz;  // Хранимый размер поддерева

    int val; // Хранимое значение в узле.
    bool reversed;

    Node *l, *r; // Указатели на левого и правого ребёнка
};

// Создание нового узла. Здесь мы должны инициализировать все поля узла, и при этом
// мы вполне вольны разместить вершину там, где хотим. Для простоты пользуемся системным
// выделителем памяти, однако одна из возможных оптимизаций - предвыделение всех необходимых
// ресурсов и написание собственного (более простого/быстрого) выделителя.
Node *new_node(int val)
{
    Node *result = new Node;
    result->y = rand();
    result->sz = 1;     // По сути, новый узел задаёт нам декартово дерево из одного узла,
                        // и размер такого дерева будет равен 1.
    result->val = val;
    result->l = result->r = nullptr; // Не забываем указать, что у нового узла нет потомков
    result->reversed = false;
    return result;
}

// Получение размера поддерева. Функция гарантирует, что её выполнение не приведёт к ошибке
// даже при передаче ей пустого дерева.
int get_sz(Node *t)
{
    if (t == nullptr) { return 0; } // Полагаем размер пустого дерева равным нулю.
    return t->sz; // Считаем, что размер поддерева поддерживается корректно
}

// Пересчёт размера поддерева. Эту операцию надо выполнять каждый раз, когда с деревом происходят
// какие-либо изменения (то есть в любом split и merge) для поддержания корректности работы операций
// над деревом.
// Данная функция предполагает, что размеры потомков также являются корректными. Это обеспечивается
// в операциях split и merge за счёт их рекуррентной природы (размеры будут пересчитываться от листьев
// к корням после любого изменения)
void upd_sz(Node *t)
{
    if (t == nullptr) { return; }
    t->sz = 1 + get_sz(t->l) + get_sz(t->r);
}


void push(Node *t)
{
    if (t == nullptr) { return; }
    if (t->reversed == false) { return; }
    t->reversed = false;
    
    Node *temp;
    temp = t->l;
    t->l = t->r;
    t->r = temp;

    if (t->l != nullptr) { t->l->reversed ^= true; }
    if (t->r != nullptr) { t->r->reversed ^= true; }
}

// Код операции слияния (merge) остаётся ровно таким же, как и для декартового дерева по явному ключу:
// для неё важен только порядок вершины (y), мы же должны гарантировать соотношение значений ключей в
// левом и правом поддеревьях, но, поскольку у нас явного ключа нет, у нас "автомагически" получится
// верное дерево
Node *merge(Node* t1, Node *t2)
{
    push(t1);
    push(t2);
    if (t1 == nullptr) { return t2; }
    if (t2 == nullptr) { return t1; }
    if (t1->y > t2->y)
    {
        t1->r = merge(t1->r, t2);
        upd_sz(t1);
        return t1;
    }
    else
    {
        t2->l = merge(t1, t2->l);
        upd_sz(t2);
        return t2;
    }
}

// Разбиение дерева на два поддерева - одно с вершинами с порядковыми номерами [0..x), другое - [x..t->sz)
// Здесь придётся делать небольшие изменения: например, поскольку ключа уже нет, надо уметь его вычислить, зная
// размеры каждого поддерева.
void split(Node *t, int x, Node *&t1, Node *&t2)
{
    push(t);
    if (t == nullptr)
    {
        t1 = t2 = nullptr;
        return;
    }
    // Заметим, что порядковый номер текущей вершины в прямом обходе равен размеру её левого поддерева.
    // (Действительно, ведь в прямом обходе мы должны сначала пройти всех левых детей, прежде чем вернёмся
    // к корню). Следовательно, если размер текущего левого поддерева меньше, чем индекс разбиения, то
    // оно целиком отправится в первое дерево, а разбивать нам надо будет правое поддерево.
    if (get_sz(t->l) < x)
    {
        // Корень и всё левое поддерево должны отправиться в первое дерево-результат, а правое поддерево надо
        // продолжить разбивать. Вот только индекс разбиения будет уже другим: корень и левое поддерево содержат
        // get_sz(t->l) + 1 узел, и именно настолько надо уменьшить наш индекс разбиения.
        split(t->r, x - get_sz(t->l) - 1, t->r, t2);
        t1 = t;
    }
    else
    {
        // Текущая вершина находится правее индекса разбиения, следовательно, она должна отправиться во
        // второе дерево. При этом индекс разбиения трогать не нужно.
        split(t->l, x, t1, t->l);
        t2 = t;
    }
    upd_sz(t);
}


// Печать всего дерева. Просто обходим наше дерево как обычное бинарное дерево поиска,
// вместо того, чтобы каждый раз пользоваться get_value.
void print_tree(Node *t)
{
    push(t);
    if (t == nullptr) { return; }
    print_tree(t->l);
    cout << t->val << " ";
    print_tree(t->r);
}


Node *reverse(Node *t, int a, int b)
{
    Node *l, *r, *m;
    split(t, a - 1, l, r);
    split(r, b - a + 1, m, r);

    // std::cout << "DDDDEBUGGGG" << std::endl;
    // print_tree(l);
    // std::cout << std::endl;
    // print_tree(m);
    // std::cout << std::endl;
    // print_tree(r);
    // std::cout << std::endl;
    // std::cout << "DDDDEBUGGGG" << std::endl;

    m->reversed ^= true;
    return merge(merge(l, m), r);
}

// Создание дерева из массива - просто слияние текущего дерева с новыми деревьями, образованными из
// элементов заданного массива. Для простоты упаковываем исходный массив в вектор.
Node *from_N(int N)
{
    Node *result = nullptr;
    for (int i = 1; i <= N; ++i)
    {
        result = merge(result, new_node(i));
    }
    return result;
}


int main() {
    int N, m;
    std::cin >> N >> m;
    Node *tree = from_N(N);
    print_tree(tree);
    std::cout << std::endl;

    int a, b;
    for(int i = 1; i <= m; ++i)
    {
        std::cin >> a >> b;
        reverse(tree, a, b);
        print_tree(tree);
        std::cout << std::endl;
    }
    print_tree(tree);

    return 0;
}
